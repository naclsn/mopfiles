#!/usr/bin/env python3
"""
Usage: sayrver [-r] [<addr>]:<port> [<mime>:<data...>]
       defaults to  :8080 plain:hi :3

This is a really small, no dependencies, Python server that
simply prints out everything from the requests it gets and
replies with a predetermined reply, for examples:
    * plain:hello world
    * json:{"coucou": 42}
    * file:resp.json

Change the reply while running with ^C once. Twice exits.
Example of using '-r' to stash and replay:

    $ sayrver -r :8080 >stashed.py
    [..]
    $ python
    >>> from http.client import HTTPConnection
    >>> from stashed import REQUESTS
    >>> from urllib.parse import urlencode
    >>> conn = HTTPConnection("localhost:8080")
    >>> for r in REQUESTS: conn.request(
    ...   r['method'],
    ...   f"{r['path']};{r['params']}?{urlencode(r['query'])}#{r['fragment']}",
    ...   r['body'],
    ...   dict(r['headers']),
    ... )
    >>> conn.close()
"""

from datetime import datetime
from http.server import BaseHTTPRequestHandler, HTTPServer
from io import IOBase
from json import load
from pprint import pformat
from re import compile
from sys import argv, stderr, stdout
from urllib.parse import parse_qs, urlparse

parse = compile(
    r'(\'(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PUT|TRACE|\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}Z?)?|\d{2}:\d{2}:\d{2}Z?|(?:file|https?|ftps?)://.*")\')|([\'"])((?:\\\2|.|\n)*?)\2|(\d+(?:\.\d+)?)|(True|False|Null)|(#.*)'
)
colo = lambda rpr: parse.sub(
    "\x1b[36m\\1\x1b[32m\\2\\3\\2\x1b[33m\\4\x1b[34m\\5\x1b[37m\\6\x1b[m", rpr
)
puts = lambda txt: print(colo(txt))


class Sayrver(BaseHTTPRequestHandler):
    reply: "tuple[str, bytes]" = ("text/plain", b"hi :3")
    rawbody = False
    separator = ",  # ==="

    class _Content:
        def __init__(self, length: int, rfile: IOBase):
            self.total = self.left = length
            self.rfile = rfile

        def readable(self):
            return True

        def read(self, size: int | None = None, /) -> bytes:
            if not size or size < 0:
                return self.rfile.read(self.left)
            read = min(size, self.left)
            self.left -= read
            return self.rfile.read(read)

    def _do(self, method: str):
        parts = urlparse(self.path)
        length = int(self.headers.get("Content-Length", 0))
        content = Sayrver._Content(length, self.rfile)
        puts(
            pformat(
                {
                    "_dt": datetime.now(),
                    "method": method,
                    "path": parts.path,
                    "params": parts.params,
                    "query": parse_qs(parts.query),
                    "fragment": parts.fragment,
                    "headers": self.headers.items(),
                    "body": content.read() if Sayrver.rawbody else b"",
                }
            )
        )

        if not Sayrver.rawbody and length:
            match self.headers.get("Content-Type", "").split(";")[0].strip():
                case "application/json":
                    puts(pformat(load(content)))
                case "application/x-www-form-urlencoded":
                    puts(
                        pformat(
                            [
                                tuple(map(bytes.decode, pair.split(b"=")))
                                for pair in content.read().split(b"&")
                            ]
                        )
                    )
                case (
                    "application/x-httpd-php"
                    | "application/x-sh"
                    | "application/xhtml+xml"
                    | "application/xml"
                    | "text/calendar"
                    | "text/css"
                    | "text/csv"
                    | "text/html"
                    | "text/javascript"
                    | "text/plain"
                ):
                    print(content.read().decode(errors="replace"))
                case _:
                    puts(f"{pformat(content.read(120))} # (total {length}B)")

        self.send_response(200)
        self.send_header("Content-Type", Sayrver.reply[0])
        self.end_headers()
        self.wfile.write(Sayrver.reply[1])

        puts(Sayrver.separator)
        stdout.flush()

    for it in "DELETE GET HEAD POST PUT".split():
        exec(f"def do_{it}(self): self._do('{it}')")


def parsereply(usr: str):
    if not usr:
        return print("reply unchanged", file=stderr)

    type, found, text = usr.partition(":")
    if not found:
        return print("no mime type, repl unchanged", file=stderr)

    if "file" == type:
        try:
            with open(text, "rb") as file:
                content = file.read()
        except FileNotFoundError:
            return print(f"no file {text!r}, repl unchanged", file=stderr)
        _, _, type = text.rpartition(".")
    else:
        content = text.encode()

    mime = type if "/" in type else MIME.get(type, "text/plain")
    return mime, content


def main():
    if argv and "-r" == argv[0]:
        argv.pop(0)
        Sayrver.rawbody = True
        global puts
        puts = print

    if not argv:
        argv.append(":8080")

    name, port = argv.pop(0).split(":")
    name = name or "localhost"
    port = int(port)
    puts(f"'''received on {name}:{port}'''")

    if argv:
        newreply = parsereply(" ".join(argv))
        if newreply:
            Sayrver.reply = newreply

    puts("REQUESTS = [")
    while 1:
        try:
            HTTPServer(
                server_address=(name, port),
                RequestHandlerClass=Sayrver,
            ).serve_forever()

        except KeyboardInterrupt:
            print(f"urrent reply ({Sayrver.reply[0]}):", file=stderr)
            print(colo(pformat(Sayrver.reply[1])), file=stderr)
            print("new reply (empty to keep): ", end="", file=stderr)
            try:
                usr = input()
            except EOFError:
                usr = ""
            except KeyboardInterrupt:
                print("aca", file=stderr)
                break

            newreply = parsereply(usr)
            if newreply:
                Sayrver.reply = newreply
    puts("]")


MIME = {
    "3g2": "video/3gpp2",
    "3gp": "video/3gpp",
    "7z": "application/x-7z-compressed",
    "aac": "audio/aac",
    "abw": "application/x-abiword",
    "apng": "image/apng",
    "arc": "application/x-freearc",
    "avi": "video/x-msvideo",
    "avif": "image/avif",
    "azw": "application/vnd.amazon.ebook",
    "bin": "application/octet-stream",
    "bmp": "image/bmp",
    "bz": "application/x-bzip",
    "bz2": "application/x-bzip2",
    "cda": "application/x-cdf",
    "csh": "application/x-csh",
    "css": "text/css",
    "csv": "text/csv",
    "doc": "application/msword",
    "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "eot": "application/vnd.ms-fontobject",
    "epub": "application/epub+zip",
    "gif": "image/gif",
    "gz": "application/gzip",
    "htm": "text/html",
    "html": "text/html",
    "ico": "image/vnd.microsoft.icon",
    "ics": "text/calendar",
    "jar": "application/java-archive",
    "jpeg": "image/jpeg",
    "jpg": "image/jpeg",
    "js": "text/javascript",
    "json": "application/json",
    "jsonld": "application/ld+json",
    "mid": "audio/midi",
    "midi": "audio/x-midi",
    "mjs": "text/javascript",
    "mp3": "audio/mpeg",
    "mp4": "video/mp4",
    "mpeg": "video/mpeg",
    "mpkg": "application/vnd.apple.installer+xml",
    "odp": "application/vnd.oasis.opendocument.presentation",
    "ods": "application/vnd.oasis.opendocument.spreadsheet",
    "odt": "application/vnd.oasis.opendocument.text",
    "oga": "audio/ogg",
    "ogv": "video/ogg",
    "ogx": "application/ogg",
    "opus": "audio/ogg",
    "otf": "font/otf",
    "pdf": "application/pdf",
    "php": "application/x-httpd-php",
    "plain": "text/plain",
    "png": "image/png",
    "ppt": "application/vnd.ms-powerpoint",
    "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "rar": "application/vnd.rar",
    "rtf": "application/rtf",
    "sh": "application/x-sh",
    "svg": "image/svg+xml",
    "tar": "application/x-tar",
    "tif": "image/tiff",
    "tiff": "image/tiff",
    "ts": "video/mp2t",
    "ttf": "font/ttf",
    "txt": "text/plain",
    "urlencoded": "application/x-www-form-urlencoded",
    "vsd": "application/vnd.visio",
    "wav": "audio/wav",
    "weba": "audio/webm",
    "webm": "video/webm",
    "webp": "image/webp",
    "woff": "font/woff",
    "woff2": "font/woff2",
    "xhtml": "application/xhtml+xml",
    "xls": "application/vnd.ms-excel",
    "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "xml": "application/xml",
    "xul": "application/vnd.mozilla.xul+xml",
    "zip": "application/zip",
}

argv.pop(0)
print(__doc__, file=stderr) if "-h" in argv else main()
